use anchor_lang::prelude::*;

/// A payload generated by a 'deposit btc' event.
pub struct MintAction {
    pub action: u32,
    pub to_chain: [u8; 32],
    pub recipient: Pubkey,
    pub amount: u64,
    pub txid: [u8; 32],
    pub vout: u32,
}

/// A payload generated by the user for paying a fee associated with the `mint_with_fee`
/// instruction.
pub struct FeeAction {
    pub action: u32,
    pub chain_id: [u8; 32],
    pub verifying_contract: Pubkey,
    pub fee: u64,
    pub expiry: u64,
}

/// A payload generated by a 'next validator set' event.
pub struct ValsetAction {
    pub action: u32,
    pub epoch: u64,
    pub validators: Vec<[u8; 64]>,
    pub weights: Vec<u64>,
    pub weight_threshold: u64,
    pub height: u64,
}

impl ValsetAction {
    /// Encodes a ValsetAction according to the EVM ABI encoder spec:
    /// https://docs.soliditylang.org/en/latest/abi-spec.html#formal-specification-of-the-encoding
    pub fn abi_encode(&self) -> Vec<u8> {
        let mut buffer = vec![];

        // First, simply encode action bytes as if it were the function selector.
        buffer.extend(self.action.to_be_bytes());

        // Encode epoch. We encode all following values into 32-byte slots as per the EVM ABI
        // encoder specification.
        let epoch_bytes = self.epoch.to_be_bytes();
        let mut epoch_slot = vec![0u8; 32 - epoch_bytes.len()];
        epoch_slot.extend(epoch_bytes);
        buffer.extend(epoch_slot);

        // We set the offsets for the validators and the weights.
        // For the validators, this is simple; it's always constant.
        let validators_offset = 160u64;
        let validators_bytes = validators_offset.to_be_bytes();
        let mut validators_slot = vec![0u8; 32 - validators_bytes.len()];
        validators_slot.extend(validators_bytes);
        buffer.extend(validators_slot);

        // For the weights, some extra calculation is needed.
        // It'll be 3 slots + validators length slot + offset slot for each validator + 4 slots per
        // validator public key + zero slot + slot for weights data part.
        let weights_offset = 3 * 32 + 32 + 5 * 32 * self.validators.len() + 2 * 32;
        let weights_bytes = weights_offset.to_be_bytes();
        let mut weights_slot = vec![0u8; 32 - weights_bytes.len()];
        weights_slot.extend(weights_bytes);
        buffer.extend(weights_slot);

        // Encode weight threshold.
        let weight_threshold_bytes = self.weight_threshold.to_be_bytes();
        let mut weight_threshold_slot = vec![0u8; 32 - weight_threshold_bytes.len()];
        weight_threshold_slot.extend(weight_threshold_bytes);
        buffer.extend(weight_threshold_slot);

        // Encode height.
        let height_bytes = self.height.to_be_bytes();
        let mut height_slot = vec![0u8; 32 - height_bytes.len()];
        height_slot.extend(height_bytes);
        buffer.extend(height_slot);

        // Encode actual validators.
        // Start with length.
        let validators_len_bytes = self.validators.len().to_be_bytes();
        let mut validators_len_slot = vec![0u8; 32 - validators_len_bytes.len()];
        validators_len_slot.extend(validators_len_bytes);
        buffer.extend(validators_len_slot);

        // Now, we encode offsets for each validator, since they are `bytes` and treated as dynamic
        // elements. We will have `validators.len()` offsets, so the first offset will be 32 *
        // validators.len(). Each thereafter is 128 bytes further along, 32 bytes for the length
        // slot, and 96 bytes to encode each public key.
        let mut offset = 32 * self.validators.len();
        self.validators.iter().for_each(|_| {
            let offset_bytes = offset.to_be_bytes();
            let mut offset_slot = vec![0u8; 32 - offset_bytes.len()];
            offset_slot.extend(offset_bytes);
            buffer.extend(offset_slot);

            offset += 128;
        });

        // Now we encode the validator public keys. Each public key is prefixed by a length slot,
        // and then the bytes of the public key followed by right-padding up to mod 32.
        self.validators.iter().for_each(|validator| {
            let length_bytes = 65u64.to_be_bytes();
            let mut length_slot = vec![0u8; 32 - length_bytes.len()];
            length_slot.extend(length_bytes);
            buffer.extend(length_slot);

            // We insert the secp256k1 prefix for an uncompressed key, `0x04`.
            buffer.push(0x04);
            buffer.extend(validator);
            // We need to keep slots of 32 bytes so after encoding the public key, we fill up the
            // buffer with 31 zeros.
            buffer.extend(vec![0u8; 31]);
        });

        // Encode actual weights.
        // This is a bit easier since we're not dealing with a dynamic field here, we just encode
        // the length and then each weight.
        let weights_len_bytes = self.weights.len().to_be_bytes();
        let mut weights_len_slot = vec![0u8; 32 - weights_len_bytes.len()];
        weights_len_slot.extend(weights_len_bytes);
        buffer.extend(weights_len_slot);

        self.weights.iter().for_each(|weight| {
            let weight_bytes = weight.to_be_bytes();
            let mut weight_slot = vec![0u8; 32 - weight_bytes.len()];
            weight_slot.extend(weight_bytes);
            buffer.extend(weight_slot);
        });

        buffer
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valset_encoder_3() {
        let expected = "4aab1d6f000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000000f0000000000000000000000000000000000000000000000000000000000000001d0000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000004104434be45682238709526d562c099570f7e7c19f670be0a41eff5fde784b0841cea3097052b8389e6424b799eb0a4b7e7a53abb4a62016cb7a7e0ffffb3b28e2700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000410420b2a4abde0bd0a5943c8740b69d244a419ece11505afc6234f62b86c4e3575075dde75b95b988853231f210b28592bc31fa749b29dda5204186aca273413431000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041041e706ef040f760e5f97504a97479d34bffa6205b35dd97a0815e9bbd1ab8add0fb73442ff761f27d2aebab49b7b0f1ace226c56bd3391c4e47af8071358a93a1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000064";

        let action = ValsetAction {
            action: crate::constants::NEW_VALSET_ACTION,
            epoch: 2,
            validators: vec![
                hex::decode("434be45682238709526d562c099570f7e7c19f670be0a41eff5fde784b0841cea3097052b8389e6424b799eb0a4b7e7a53abb4a62016cb7a7e0ffffb3b28e270").unwrap().try_into().unwrap(),
                hex::decode("20b2a4abde0bd0a5943c8740b69d244a419ece11505afc6234f62b86c4e3575075dde75b95b988853231f210b28592bc31fa749b29dda5204186aca273413431").unwrap().try_into().unwrap(), 
                hex::decode("1e706ef040f760e5f97504a97479d34bffa6205b35dd97a0815e9bbd1ab8add0fb73442ff761f27d2aebab49b7b0f1ace226c56bd3391c4e47af8071358a93a1").unwrap().try_into().unwrap()
            ],
            weights: vec![100, 100, 100],
            weight_threshold: 240,
            height: 29,
        };

        let bytes = action.abi_encode();
        assert_eq!(hex::encode(bytes), expected);
    }

    #[test]
    fn test_valset_encoder_4() {
        let expected = "4aab1d6f000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000041047378e006183e9a5de1537b788aa9d107c67189cd358efc1d53a5642dc0a373113e8808ff945b2e03470bc19d0d11284ed24fee8bbf2c90908b640a91931b257200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004104ca1bf4568f0e73ed993c9cb80bb46492101e0847000288d1cdc246ff67ecda20da20c13b7ed03a97c1c9667ebfdaf1933e1c731d496b62d82d0b8cb71b33bfd500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004104ac2fec1927f210f2056d13c9ba0706666f333ed821d2032672d71acf47677eae4c474ec4b2ee94be26655a1103ddbd0b97807a39b1551a8c52eeece8cc48829900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004104b56056d0cb993765f963aeb530f7687c44d875bd34e38edc719bb117227901c5823dc3a6511d67dc5d081ac2a9d41219168f060f80c672c0391009cd267e4eb40000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000064";

        let action = ValsetAction {
            action: crate::constants::NEW_VALSET_ACTION,
            epoch: 2,
            validators: vec![
                hex::decode("7378e006183e9a5de1537b788aa9d107c67189cd358efc1d53a5642dc0a373113e8808ff945b2e03470bc19d0d11284ed24fee8bbf2c90908b640a91931b2572").unwrap().try_into().unwrap(), 
                hex::decode("ca1bf4568f0e73ed993c9cb80bb46492101e0847000288d1cdc246ff67ecda20da20c13b7ed03a97c1c9667ebfdaf1933e1c731d496b62d82d0b8cb71b33bfd5").unwrap().try_into().unwrap(), 
                hex::decode("ac2fec1927f210f2056d13c9ba0706666f333ed821d2032672d71acf47677eae4c474ec4b2ee94be26655a1103ddbd0b97807a39b1551a8c52eeece8cc488299").unwrap().try_into().unwrap(), 
                hex::decode("b56056d0cb993765f963aeb530f7687c44d875bd34e38edc719bb117227901c5823dc3a6511d67dc5d081ac2a9d41219168f060f80c672c0391009cd267e4eb4").unwrap().try_into().unwrap()
            ],
            weights: vec![100, 100, 100, 100],
            weight_threshold: 320,
            height: 6,
        };

        let bytes = action.abi_encode();
        assert_eq!(hex::encode(bytes), expected);
    }
}
